---
layout: post
title: '[JavaScript] 코어자바스크립트 2장. 실행 컨텍스트(1) 실행컨텍스트 개념과 호이스팅'
category: 'Javascript'
---

> 이 포스팅은 책 <코어 자바스크립트 2장 실행컨텍스트>를 읽고 정리한 글입니다.

## 1. 실행 컨텍스트란?

실행컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 환경을 가장 잘 파악할 수 있는 개념이다.

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜스택(call stack)에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.

여기서 '동일한 환경', 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, 함수 등이 있는데 전역공간의 경우 자동으로 생성되기 때문에 제외하면 결국 우리가 흔히 실행컨텍스트를 구성하는 방법은 함수를 실행하는 것 뿐이다.

예제를 보면서 콜 스택에 실행컨텍스트가 쌓이고 실행되는지 알아보자.

```jsx
//--------------(1)
var a = 1;
function outer(){
  function inner(){
    console.log(a); //undefined
    var a = 3;
  }
  inner(); //----------(2)
  console.log(a);  //1
}
outer(); //-----------(3)
console.log(a)  //1
}
```

처음 자바스크립트 코드를 실행하는 순간,  
(1) 전역 컨텍스트가 콜스택에 담긴다. 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다.

콜스택에 현재 전역 컨텍스트만 있으므로 전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 (3)에서 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜스택에 담는다.

콜스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태가 되었으므로 전역 컨텍스트와 관련된 코드의 실행을 일시 중단하고 대신 outer 실행컨텍스트와 관련된 코드, 즉 outer 함수 내부의 코드들을 순차적으로 실행한다.

<br>

![IMG_3356](https://user-images.githubusercontent.com/60246689/89371491-7f1fc280-d71e-11ea-880e-b4e814e38234.JPG)
_실행컨텍스트와 콜스택 (이미지출처: 코어자바스크립트)_
<br>

다시 (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행할 것이다.

inner 함수 내부에서 a 변수의 값을 출력하고 나면 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거된다. 그러면 outer 컨텍스트가 콜스택의 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다. a 변수의 값을 출력하고 나면 outer 함수의 실행이 종료되어 outer 실행 컨텍스트가 콜 스택에서 제거되고 클스택에는 전역 컨텍스트만 남아 있게 된다.

그런다음 실행을 중단했던 (3)의 다음줄부터 이어서 실행하고, a 변수의 값을 출력하고 나면 전역공간에는 더는 실행할 코드가 남아있지 않아 전역 컨텍스트도 제거되고 콜스택에는 아무것도 남아있지 않은 상태로 종료된다.

스택 구조를 잘 생각해보면 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없는데, 다음과 같은 정보들이 담기게 된다는걸 알아두자.

- `VariableEnvironment`:
  현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보.
  선언 시접의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음

- `LexicalEnvironment`:
  처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영됨.

- `ThisBinding`:
  this 식별자가 바라봐야 할 대상 객체

## 2. VariableEnvironment

VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 된다.

두 환경정보 모두 내부는 environmentRecord와 outer-EnvironmentReference로 구성돼 있다. 초기화 과정 중에는 사실상 동일하고 이후 코드 진행에 따라 서로 달라지게 된다.

## 3. LexicalEnvironment

lexical environment란 '사전적인' 환경정보라고 이해할 수 있다.  
어떤 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이다. ("현재 컨텍스트 내부에는 a,b,c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다.")

## 3-1. EnvironmentRecord와 호이스팅

environmentRecord는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 여기에 해당된다.

변수 정보를 수집하는 과정을 모두 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다. 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다. 여기서 호이스팅(hoisting) 개념이 등장하는데, 자바스크립트 엔진이 "식별자들을 최상단으로 끌어올려놓은(hoisting) 다음 실제 코드를 실행한다"고 인식하는 가상의 개념이다.

### 호이스팅 규칙

environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다고 했다. 몇가지 예제를 통해 살펴보자.

```jsx
function a(x) {
  //수집대상 1(매개변수)
  console.log(x) //(1)
  var x
  console.log(x) //(2)
  var x = 2 //수집대상 3 (변수선언)
  console.log(x)
}
a(1)
```

인자들과 함께 함수를 호출한 경우의 동작을 살펴보면 arguments에 전달된 인자를 담는 것을 제외하면 코드 내부에서 변수를 선언한 것과 다른 점이 없다. 그러니까 인자를 함수 내부의 다른 코드보다 먼저 선언 및 할당이 이루어진 것으로 간주할 수 있다.

이 상태에서 변수 정보를 수집하는 과정, 즉 호이스팅 처리를 해보자.
environmentRecord는 현재 실행된 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 그래서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 그 자리에 그대로 남겨둔다.
그럼 이 규칙에 따라 호이스팅을 마친 상태의 코드를 보자.

```jsx
function a() {
  var x // 수집대상 1의 변수 선언
  var x // 수집대상 2의 변수 선언
  var x // 수집대상 3의 변수 선언

  x = 1 // 수집대상 1의 할당 부분
  console.log(x) //(1)
  console.log(x) //(2)
  x = 2 //수집대상 3의 할당 부분
  console.log(x) //(3)
}
```

다음은 함수 선언을 추가한 예제를 보자.

```jsx
function a() {
  console.log(b) //(1)
  var b = 'bbb' //수집 대상 1 (변수 선언)
  console.log(b) //(2)
  function b() {} // 수집 대상 2 (함수 선언)
  console.log(b) //(3)
}
a()
```

a 함수의 호이스팅은 어떻게 이루어질까?  
먼저 a 함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성된다.  
이때 변수명과 함수 선언의 정보를 위로 끌어올린다. (수집한다)  
변수는 선언부와 할당부를 나누어 선언부만 끌어올리는 반면, 함수 선언은 함수 전체를 끌어올린다.  
수집 대상 1과 2를 순서대로 끌어올리고 나면 다음과 같은 형태로 변환된다.

```jsx
function a() {
  var b //수집대상 1. 변수는 선언부만 끌어올림
  function b() {} //수집대상2. 함수 선언은 전체를 끌어올림

  console.log(b) //(1)
  b = 'bbb' //변수에 할당부는 그대로 남김
  console.log(b) //(2)
  console.log(b) //(3)
}

a()
```

해석의 편의를 위해 하나 더 바꿔보자.  
호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있다.

```jsx
function a() {
  var b
  var b = function b() {} // 바뀐 부분

  console.log(b) //(1)
  b = 'bbb' //변수에 할당부는 그대로 남김
  console.log(b) //(2)
  console.log(b) //(3)
}
a()
```

호이스팅을 고려하지 않은 상태에서 예상되는 결과는 (1) 에러 또는 undefined, (2) 'bbb', (3) b함수 였지만  
실제로는 (1) b 함수, (2) 'bbb', (3) 'bbb'라는 전혀 다른 결과가 나왔다.

## 정리

이렇게 자바스크립트에서 실행컨텍스트의 개념과 컨텍스트를 구성하는 환경 정보를 수집하는 방법(호이스팅)에 대해 알아보았다.

함수의 호이스팅에 대한 추가 정보로 함수 선언문과 함수 표현식에 대한 개념을 공부해야하는데 글이 길어져 다음 포스팅에 이어서 정리하려고 한다.

그리고 실행컨텍스트를 구성하는 나머지 요소 outerEnvironmentReference와 ThisBinding에 대해서도 차근차근 공부해 나갈 예정이다.

<br />

<br />

