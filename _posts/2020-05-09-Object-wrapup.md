---
layout: post
title: '[JavaScript] 객체(object)의 특성 Wrap-up'
tags: JavaScript
---

## Object (객체)

객체는 키(key)-값(value) 쌍으로된 데이터의 모음으로, 순서에 상관없이 저장이 된다.   
그래서 배열처럼 순서대로 index로 접근하는게 아니라 key로 데이터에 접근한다.  
키는 마치 특정 값을 갖고 있는 변수 같은 역할을 해서, 해당 키로 프로퍼티에 어떤 값이 저장되었는지 알 수 있다.

![](https://images.velog.io/images/rimu/post/d36da375-bcf2-4a14-b45e-06ec7bc8bf53/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.53.07.png)

```
  let plan1 = {
  name: "Basic",
  price: 3.99,
  space: 100,
  transfer: 1000,
  pages: 10
};
```

객체의 키에는 스페이스, 한글, 특수문자 등이 들어갈 수 있는데 이건 변수를 선언할 때는 할 수 없던 표현이다.
color와 같이 특수문자가 없는 문자열의 경우 따옴표를 생략하고 쓸 수 있다.

```javascript
let difficult = {
  'my name': 'boong',
  color: 'silver',
  키: '한글인 키는 따옴표가 없어도 되는군!!',
  '!키': '느낌표 있는 키는 따옴표가 필요하군',
  $special: '$는 없어도 되는군',
}
```

## 객체 접근하기

객체에서 제일 중요한건 접근하는방법을 가장 잘 정리해두는것이다.
백엔드에서 데이터가 올때 복잡한 형식으로 되어 있는데 이걸 잘 접근할 줄 알아야한다.

1.마침표(.)를 사용하여 `객체명.프로퍼티명`

2.대괄호([ ])를 사용하여 `객체명["프로퍼티명"]`

#### 대괄호 접근만 써야할때

객체에서 dot(.)으로 접근하는 것이 제일 편하지만 몇가지 경우에서는 대괄호 접근만 써야한다.

1.변수로 선언한 프로퍼티명을 이용해서 접근할때

```javascript
let plan1 = {
  name: 'Basic',
}

let propertyName = 'name'

console.log(plan1[propertyName]) //"Basic"
```

2.프로퍼티명에 띄어쓰기가 있을때

3.프로퍼티명이 숫자일때

4.그외 JavaScript에서 식별자로 허용되지 않는 문자가 들어간 프로퍼티명을 사용했을때

<br>

#### 중첩된 객체 접근하기

```javascript
let myProfile = {
  name: '김개발',
  address: {
    email: 'geabal@gmail.com',
    home: '위워크',
  },
  'my favorite': {
    food: [
      {
        name: '샐러드',
        price: 3500,
      },
      {
        name: '삼겹살',
        price: 15000,
      },
    ],
    hobby: ['축구'],
  },
}
```

위의 객체에서 '샐러드'라는 값에 접근하려면?
`myProfile['my favorite']['food'][0]['name']`

#### 정의된 객체에서 프로퍼티값 수정하기

```javascript
let myObj = {
  property1: 'hello',
  property2: [1, 2, 3, 4, 5],
  property3: {
    childproperty: 'haha',
  },
}

let name = 'property1'

myObj[name] = ['hi', 'hello']

console.log(myObj[name])
//  ["hi", "hello"];
```

#### 정의된 객체에서 새로운 프로퍼티 추가하기

객체의 큰 특징 중 하나는 이미 프로퍼티명(키)이 존재하는데 다시 한 번 할당하면 값이 교체(수정)된다. 그리고 해당 프로퍼티가 존재하지 않으면 새로운 프로퍼티를 추가한다. 이 특징의 근본적인 이유는 바로 밑에서 등장한다.

```javascript
myObj.property3.siblingproperty = [3, 6, 9];

/*결과: myObj = {
  property1: "hello",
  property2: [1,2,3,4,5],
  property3: {
    childproperty: "haha"
    siblingproperty:
  },
};
```

## 객체의 특별한 점

**"객체는 reference가 저장된다"**
객체를 변수에 저장하면 객체 리터럴 자체가 저장 되는게 아니라, 사실은 reference가 저장된다. 아래 예시를 보면 객체에 똑같은 데이터를 할당하고 그 값을 비교했는데 결과가 false라고 출력된다.

```javascript
const hiObj = {
  name: '안녕',
}
const helloObj = {
  name: '안녕',
}
console.log('객체비교 =>', hiObj === helloObj)
//객체비교 => false
```

그 이유는 객체는 변수에 저장할때, 그 객체 자체를 그대로 저장하는것이 아니라, 객체가 담긴 어떤 메모리의 reference를 저장한다.
![](https://images.velog.io/images/rimu/post/01d56eaa-eef7-433c-b618-b98f6bc960cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.35.12.png)

그래서 hiObj가 갖고 있는 진짜 값은 메모리 주소인 reference 인 것.
하지만 hiObj를 불러올 때 메모리 주소를 반환하는 것이 아니라 해당 메모리에 저장된 데이터를 반환해준다.

그래서 눈에 보이는 데이터는 똑같지만, hiObj와 helloObj가 갖고 있는 진짜 값은 다르다.

```javascript
console.log('객체비교 =>', hiObj === helloObj)
//객체비교 => false

console.log('객체값비교 =>', hiObj.name === helloObj.name)
//객체값비교 => true
```

그래서 const로 선언한 객체에 새로운 객체를 할당하면 오류가 나지만
(새로운 메모리 레퍼런스로 수정을 시도하기 때문), 프로퍼티로 접근해서 얼마든지 수정할 수 있다.

## 객체의 키를 변수로 접근하기

객체의 프로퍼티명(키)를 사용하는 방법은 다양한 방식으로 활용할 수 있다.
information이라는 객체를 하나 만들어서 생각해보자.

```javascript
const information = {
  name: '김개발',
}
```

그런데 여기에 키 하나를 생성하고, 그 키에 값을 할당해주려고 한다.
그런데 키와 값을 변수를 통해 받아오고싶다면 어떻게 해야할까?

![](https://images.velog.io/images/rimu/post/bc6006af-a0b4-46a9-8cdc-0a84d3a108b6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.09.39.png)

변수 verb의 값을 객체의 새로운 키, 그리고 변수 project의 값을 새로생성할 키의 값으로 사용한다고 했을때 다음과 같이 사용할 수 있다.

![](https://images.velog.io/images/rimu/post/e733ff85-aede-4254-80f7-7023ab57d173/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.09.58.png)

변수명 자체를 대괄호접근법을 이용해서 객체에 새로운 키와 값을 할당해준것이다. 키와 값이 잘 생성되었는지 확인해보기 위해 information 객체를 보니 잘 추가가 되었다.

## 객체 순회하기

객체는 순서가 없고 키를 통해서만 접근이 가능하기 때문에 요소 하나하나에 접근하여 순회하고 싶을때 배열과 달리 어려울거라고 생각할 수 있다. 하지만 객체의 특성을 이용해서 순회를 할 수 있는데 크게 두가지 방법이 있다.

### 1. Object.keys( )

`Object.keys()` 메서드는 어떤 객체가 가지고 있는 키들의 목록을 배열로 리턴하는 메서드이다. 객체의 내장 메서드가 아니라 객체 생성자인 Object가 직접 가지고 있는 메서드이다.
![](https://images.velog.io/images/rimu/post/0b6f86d4-00d3-4d70-a032-d103c9f8187c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.28.37.png)

`Object.keys()`가 리턴하는 값은 배열이기 때문에 이걸로 우리가 반복문을 사용할 수 있다.
![](https://images.velog.io/images/rimu/post/71dc123c-20fe-43f0-84d4-1b19316a3541/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.37.05.png)

ES6 문법에서는 이 외에도 Object 생성자의 메서드인 `Object.values`와 `Object.entries`가 추가 되어서 유용하게 사용할 수 있게 되었다.

### Object.values()

객체의 값들로 이루어진 배열을 리턴한다.
![](https://images.velog.io/images/rimu/post/7f857377-48c6-458c-bd1a-a9542f82e6ba/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.45.35.png)

### Object.entries()

객체의 키와 값의 쌍으로 이루어진 길이 2짜리 배열로 이루어진 배열을 리턴한다. 각 배열에서 인덱스[0]의 값은 키를, 인덱스[1]의 값은 키에 해당하는 값들을 가지게 된다.

![](https://images.velog.io/images/rimu/post/ba19b689-91de-448e-8e84-99387374d8b5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.48.06.png)

### 2. for - in

객체를 순회하는 두번째 방법은 for-in문이다. 반복문 for문과 같은 종류의 문법이지만 객체와 배열을 위해 특별히 존재하는 ES6에서 추가된 문법이다.
기존의 배열에서 사용하던 for문을 (let i = 0 ; i < arr.length; i++)를 간단하게 축약한 문법

![](https://images.velog.io/images/rimu/post/239e6a61-7752-4644-8e2c-13db5528df5d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.52.36.png)

그럼 이 for-in문을 객체에서 어떻게 사용할 수 있는지 알아보자.

![](https://images.velog.io/images/rimu/post/493974e1-2d16-4539-89da-f239ba61e54b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.56.39.png)

이렇게 객체를 가지고 for-in문을 사용하면, 인덱스에 해당하는 변수가 숫자가 아닌 객체의 각각의 키를 할당받게 된다!
객체의 키를 변수로 접근하는 기능과 함께 사용해서 아주 신박한 기능이다.


<br>

### 객체의 키에 변수로 접근 + 반복문을 이용하는 예제

```javascript
getExamResult 함수를 구현해주세요.
인자 scores 는 다음과 같은 객체입니다.
객체의 요소의 갯수 및 키의 이름들은 달라질 수 있습니다.
객체의 값은 다음 9가지 문자열 중에서 하나를 가지고 있습니다.

('A+', 'A', 'B+', 'B', 'C+', 'C', 'D+', 'D', 'F')

{
'생활속의회계': 'C',
'논리적글쓰기': 'B',
'독일문화의이해': 'B+',
'기초수학': 'D+',
'영어회화': 'C+',
'인지발달심리학': 'A+',
}

인자 requiredClasses 는 다음과 같이 문자열로 된 배열입니다.
['영어회화', '기초수학', '공학수학', '컴퓨터과학개론']
다음 조건을 만족하는 객체를 리턴하도록 함수를 구현해주세요

1. scores 객체가 가지고 있는 키들은 새로운 객체에 포함되어야 합니다.
   단, 그 값들은 다음 원리에 따라 숫자로 바뀌어 할당되어야 합니다.
   A+ => 4.5
   A => 4
   B+ => 3.5
   B => 3
   C+ => 2.5
   C => 2
   D+ => 1.5
   D => 1
   F => 0

2. requiredClass 배열의 요소로는 존재하지만, scores의 키로는 존재하지 않는 항목이 있다면,
   해당 요소는 새로운 객체의 키가 되고, 값으로 0을 가져야 합니다.
   위에서 예시로 묘사된 객체와 배열이 인자로 들어왔다면,
   다음과 같은 객체과 리턴됩니다. (요소간 순서는 다를수 있지만, 채점에 무관합니다.)
   {
   '생활속의회계': 2,
   '논리적글쓰기': 3,
   '독일문화의이해': 3.5,
   '기초수학': 1.5,
   '영어회화': 2.5,
   '인지발달심리학': 4.5,
   '공학수학': 0,
   '컴퓨터과학개론': 0,
   }
```

![](https://images.velog.io/images/rimu/post/5b9b372a-1bc5-4d11-8f28-57853b70a9b4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-04-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.20.48.png)

<br />
<br />
<br />

> 이글은 Wecode 부트캠프의 공부자료를 정리한 내용입니다.
